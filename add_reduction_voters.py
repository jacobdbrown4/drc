import spydrnet as sdn
from spydrnet.uniquify import uniquify
from spydrnet.util.selection import Selection
from spydrnet_shrec import apply_nmr
from spydrnet_shrec.analysis.find_voter_insertion_points import find_voter_insertion_points
from spydrnet_shrec.transformation.replication.organ_insertion import insert_organs
from spydrnet_shrec.transformation.replication.organ import XilinxTMRVoter

def identify_reduction_voters(replicas,suffix):
    '''
    Looks through a replicated design and identifies any spots where reduction voters are needed.

    :param replicas: the map from an original element to its replicas generated by apply_nmr()
    :param suffix: string appended to the replicated instances' names e.g. 'TMR' or 'DWC'
    :return: list of outer pins
    '''
    total_point_count = 0
    insertion_points = []
    for primary in replicas:
        if primary.__class__ is sdn.Instance and primary.is_leaf():
            next_instances_original = []
            other_next_instances = []
            for pin in get_output_pins(primary):
                next_instances_original += get_next_instances(pin,suffix)
            for replica in replicas[primary]:
                for pin in get_output_pins(replica):
                    other_next_instances += get_next_instances(pin,suffix)

            if set(next_instances_original) != set(other_next_instances):
                # print(primary.name,'of',primary.parent.name,'\n',set(next_instances_original),'\n',set(other_next_instances))
                total_point_count += 1
                output_pin = next(primary.get_pins(selection=Selection.OUTSIDE,filter=lambda x: x.inner_pin.port.direction is sdn.OUT))
                if output_pin:
                    insertion_points.append(output_pin)

    print("Identified {} insertion points for reduction voters.".format(total_point_count))
    return insertion_points

def get_next_instances(current_pin,suffix):
    next_instances = []
    next_instances = list(pin2 for pin2 in current_pin.wire.get_pins(selection = Selection.OUTSIDE, filter = lambda x: (x is not current_pin)))
    next_instances = list(fix_instance_name(x.instance,suffix) for x in next_instances)
    return next_instances

def get_output_pins(current_instance):
    output_pins = []
    for pin in current_instance.get_pins(selection=Selection.OUTSIDE,filter=lambda x: x.inner_pin.port.direction is sdn.OUT):
        if pin.wire:
            output_pins.append(pin)
    return output_pins

def fix_instance_name(current_instance,suffix):
    modified_name = None
    start_index = current_instance.name.find(suffix)
    stop_index = start_index + len(suffix) + 2
    if start_index is -1:
        modified_name = current_instance.name
    else :
        modified_name = current_instance.name[:start_index-1] + current_instance.name[stop_index:]
    return modified_name




global netlist_name
netlist_name = 'b13'

netlist = sdn.load_example_netlist_by_name(netlist_name)
uniquify(netlist)
sdn.compose(netlist,netlist_name+'.edf')

not_to_replicate = ['OBUF','anode','segment','OUTBUF']
# hinstances_to_replicate = list(netlist.get_hinstances(recursive=True, filter=lambda x: x.item.reference.is_leaf() is True))
# instances_to_replicate = list(x.item for x in hinstances_to_replicate)
# hports_to_replicate = list(netlist.get_hports())
# ports_to_replicate = list(x.item for x in hports_to_replicate)
hinstances_to_replicate = list(netlist.get_hinstances(recursive=True, filter=lambda x:(x.item.reference.is_leaf() and not any(thing in x.item.name for thing in not_to_replicate))is True))
instances_to_replicate = list(x.item for x in hinstances_to_replicate)
hports_to_replicate = list(netlist.get_hports(filter = lambda x: (x.item.direction is sdn.IN and 'clk' not in x.item.name) is True))
ports_to_replicate = list(x.item for x in hports_to_replicate)

insertion_points = find_voter_insertion_points(netlist, [*hinstances_to_replicate, *hports_to_replicate], {'FDRE', 'FDSE', 'FDPE', 'FDCE'})
replicas = apply_nmr([*instances_to_replicate, *ports_to_replicate], 3, name_suffix='TMR', rename_original=True)
voters = insert_organs(replicas,insertion_points,XilinxTMRVoter(),'VOTER')
additional_insertion_points = []
additional_insertion_points = identify_reduction_voters(replicas,'TMR')
voters2 = insert_organs(replicas,additional_insertion_points,XilinxTMRVoter(),'VOTER')
netlist.compose(netlist_name+'_red_voters.edf')


from spydrnet_shrec.utils.design_rule_check.drc_connections_after_replication_and_insertion import check_connections
netlist1 = sdn.parse(netlist_name+'.edf')
netlist2 = sdn.parse(netlist_name+'_red_voters.edf')

check_connections(netlist1,netlist2,'TMR','VOTER',True)